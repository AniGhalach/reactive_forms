// Copyright 2020 Joan Pablo Jim√©nez Milian. All rights reserved.
// Use of this source code is governed by the MIT license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:reactive_forms/reactive_forms.dart';

/// This is the base class for [FormGroup], [FormArray] and [FormControl].
///
/// It provides some of the shared behavior that all controls and groups have,
/// like running validators, calculating status, and resetting state.
///
/// It also defines the properties that are shared between all sub-classes,
/// like value and valid.
///
/// It shouldn't be instantiated directly.
abstract class AbstractControl<T> {
  final _statusChanges = StreamController<ControlStatus>.broadcast();
  final _valueChanges = StreamController<T>.broadcast();
  final _touchChanges = StreamController<bool>.broadcast();
  final List<ValidatorFunction> _validators;
  final List<AsyncValidatorFunction> _asyncValidators;
  Map<String, dynamic> _errors = {};

  T _value;

  ControlStatus _status;

  /// The parent control.
  AbstractControl _parent;

  /// Async validators debounce timer.
  Timer _debounceTimer;

  /// Async validators debounce time in milliseconds.
  final int _asyncValidatorsDebounceTime;

  bool _touched = false;

  /// Gets if the control is touched or not.
  ///
  /// A control is touched when the user taps on the ReactiveFormField widget
  /// and then remove focus or completes the text edition. Validation messages
  /// will begin to show up when the FormControl is touched.
  bool get touched => _touched;

  /// Marks the control as touched.
  void touch() {
    _updateTouched(true);
  }

  /// Marks the control as untouched.
  void untouch() {
    _updateTouched(false);
  }

  void _updateTouched(bool value) {
    if (_touched != value) {
      _touched = value;
      _touchChanges.add(_touched);
    }
  }

  /// Constructor of the [AbstractControl].
  AbstractControl({
    List<ValidatorFunction> validators,
    List<AsyncValidatorFunction> asyncValidators,
    int asyncValidatorsDebounceTime = 250,
    bool touched = false,
    bool disabled = false,
  })  : assert(asyncValidatorsDebounceTime >= 0),
        _validators = validators ?? const [],
        _asyncValidators = asyncValidators ?? const [],
        _asyncValidatorsDebounceTime = asyncValidatorsDebounceTime {
    _status = disabled ? ControlStatus.disabled : ControlStatus.valid;
    _updateTouched(touched);
  }

  /// The list of functions that determines the validity of this control.
  ///
  /// In [FormGroup] these come in handy when you want to perform validation
  /// that considers the value of more than one child control.
  List<ValidatorFunction> get validators => List.unmodifiable(_validators);

  /// The list of async functions that determines the validity of this control.
  ///
  /// In [FormGroup] these come in handy when you want to perform validation
  /// that considers the value of more than one child control.
  List<AsyncValidatorFunction> get asyncValidators =>
      List.unmodifiable(_asyncValidators);

  /// The current value of the control.
  T get value => _value;

  /// Sets the value to the control
  set value(T value) {
    if (_value != value) {
      _value = value;
      this.updateValueAndValidity();
    }
  }

  /// Gets the parent control.
  AbstractControl get parent => this._parent;

  /// Sets the parent of the control.
  ///
  /// This is for internal use only.
  @protected
  set parent(AbstractControl parent) {
    this._parent = parent;
  }

  /// An object containing any errors generated by failing validation,
  /// or empty [Map] if there are no errors.
  Map<String, dynamic> get errors => Map.unmodifiable(_errors);

  /// A [Stream] that emits the status every time it changes.
  Stream<ControlStatus> get statusChanged => _statusChanges.stream;

  /// A [Stream] that emits the value of the control every time it changes.
  Stream<T> get valueChanges => _valueChanges.stream;

  /// A [Stream] that emits an event every time the control
  /// is touched or untouched.
  Stream<bool> get touchChanges => _touchChanges.stream;

  /// A control is valid when its [status] is ControlStatus.valid.
  bool get valid => this.status == ControlStatus.valid;

  /// A control is invalid when its [status] is ControlStatus.invalid.
  bool get invalid => this.status == ControlStatus.invalid;

  /// A control is pending when its [status] is ControlStatus.pending.
  bool get pending => this.status == ControlStatus.pending;

  /// A control is disabled when its [status] is ControlStatus.disabled.
  bool get disabled => this.status == ControlStatus.disabled;

  /// A control is enabled as long as its [status] is
  /// not ControlStatus.disabled.
  bool get enabled => !this.disabled;

  /// True whether the control has validation errors.
  bool get hasErrors => this.errors.isNotEmpty;

  /// The validation status of the control.
  ///
  /// There are four possible validation status values:
  /// * VALID: This control has passed all validation checks.
  /// * INVALID: This control has failed at least one validation check.
  /// * PENDING: This control is in the midst of conducting a validation check.
  ///
  /// These status values are mutually exclusive, so a control cannot be both
  /// valid AND invalid or invalid AND pending.
  ControlStatus get status => _status;

  /// Enables the control. This means the control is included in validation
  /// checks and the aggregate value of its parent. Its status recalculates
  /// based on its value and its validators.
  ///
  /// When [onlySelf] is true, mark only this control.
  /// When false or not supplied, marks all direct ancestors.
  /// Default is false.
  void enable({bool onlySelf: false}) {
    if (this.enabled) {
      return;
    }
    _status = ControlStatus.valid;
    this.updateValueAndValidity(onlySelf: true);
    _updateAncestors(onlySelf);
  }

  /// Disables the control.
  ///
  /// This means the control is exempt from validation checks and excluded
  /// from the aggregate value of any parent. Its status is `DISABLED`.
  ///
  /// If the control has children, all children are also disabled.
  ///
  /// When [onlySelf] is true, mark only this control.
  /// When false or not supplied, marks all direct ancestors.
  /// Default is false.
  void disable({bool onlySelf: false}) {
    _errors.clear();
    _status = ControlStatus.disabled;
    _statusChanges.add(_status);
    _updateAncestors(onlySelf);
  }

  /// Disposes the control
  void dispose() {
    _statusChanges.close();
    _valueChanges.close();
    _asyncValidationSubscription?.cancel();
  }

  /// Resets the control.
  void reset();

  /// Sets errors on a form control when running validations manually,
  /// rather than automatically.
  void setErrors(Map<String, dynamic> errors) {
    _errors.clear();
    _errors.addAll(errors);

    _updateControlsErrors();
  }

  _updateControlsErrors() {
    _status = _calculateStatus();
    _statusChanges.add(_status);

    if (_parent != null) {
      _parent._updateControlsErrors();
    }
  }

  Map<String, dynamic> _runValidators() {
    final errors = Map<String, dynamic>();
    this.validators.forEach((validator) {
      final error = validator(this);
      if (error != null) {
        errors.addAll(error);
      }
    });

    return errors;
  }

  /// Returns true if all children disabled, otherwise returns false.
  ///
  /// This is for internal use only.
  @protected
  bool allControlsDisabled() {
    return this.disabled;
  }

  /// Returns true if all children has the specified [status], otherwise
  /// returns false.
  ///
  /// This is for internal use only.
  @protected
  bool anyControlsHaveStatus(ControlStatus status) {
    return false;
  }

  ControlStatus _calculateStatus() {
    if (this.allControlsDisabled()) {
      return ControlStatus.disabled;
    } else if (this.hasErrors) {
      return ControlStatus.invalid;
    } else if (this.anyControlsHaveStatus(ControlStatus.pending)) {
      return ControlStatus.pending;
    } else if (this.anyControlsHaveStatus(ControlStatus.invalid)) {
      return ControlStatus.invalid;
    }

    return ControlStatus.valid;
  }

  _setInitialStatus() {
    _status = this.allControlsDisabled()
        ? ControlStatus.disabled
        : ControlStatus.valid;
  }

  void _updateAncestors(bool onlySelf) {
    if (_parent != null && !onlySelf) {
      _parent.updateValueAndValidity(onlySelf: onlySelf);
    }
  }

  void updateValueAndValidity({bool onlySelf: false}) {
    _setInitialStatus();
    if (this.enabled) {
      _cancelExistingSubscription();
      _errors = _runValidators();
      _status = _calculateStatus();
      if (_status == ControlStatus.valid || _status == ControlStatus.pending) {
        _runAsyncValidators();
      }
    }

    _valueChanges.add(this.value);
    _statusChanges.add(_status);

    _updateAncestors(onlySelf);
  }

  StreamSubscription _asyncValidationSubscription;

  Future<void> _cancelExistingSubscription() async {
    if (_asyncValidationSubscription != null) {
      await _asyncValidationSubscription.cancel();
      _asyncValidationSubscription = null;
    }
  }

  /// runs async validators to validate the value of current control
  Future<void> _runAsyncValidators() async {
    if (_asyncValidators.isEmpty) {
      return;
    }

    this._status = ControlStatus.pending;

    if (_debounceTimer != null) {
      _debounceTimer.cancel();
    }

    _debounceTimer = Timer(
      Duration(milliseconds: _asyncValidatorsDebounceTime),
      () {
        final validatorsStream = Stream.fromFutures(
            this.asyncValidators.map((validator) => validator(this)));

        final errors = Map<String, dynamic>();
        _asyncValidationSubscription = validatorsStream.listen(
          (error) {
            if (error != null) {
              errors.addAll(error);
            }
          },
          onDone: () {
            this.setErrors(errors);
          },
        );
      },
    );
  }
}
