// Copyright 2020 Joan Pablo Jim√©nez Milian. All rights reserved.
// Use of this source code is governed by the MIT license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:reactive_forms/reactive_forms.dart';

/// This is the base class for [FormGroup], [FormArray] and [FormControl].
///
/// It provides some of the shared behavior that all controls and groups have,
/// like running validators, calculating status, and resetting state.
///
/// It also defines the properties that are shared between all sub-classes,
/// like value and valid.
///
/// It shouldn't be instantiated directly.
abstract class AbstractControl<T> {
  final _statusChanges = StreamController<ControlStatus>.broadcast();
  final _valueChanges = StreamController<T>.broadcast();
  final _touchChanges = StreamController<bool>.broadcast();
  final List<ValidatorFunction> _validators;
  final List<AsyncValidatorFunction> _asyncValidators;
  final Map<String, dynamic> _errors = {};

  T _value;

  ControlStatus _status;

  /// The parent control.
  FormControlCollection _parent;

  /// Async validators debounce timer.
  Timer _debounceTimer;

  /// Async validators debounce time in milliseconds.
  final int _asyncValidatorsDebounceTime;

  bool _touched = false;

  /// Gets if the control is touched or not.
  ///
  /// A control is touched when the user taps on the ReactiveFormField widget
  /// and then remove focus or completes the text edition. Validation messages
  /// will begin to show up when the FormControl is touched.
  bool get touched => _touched;

  /// Marks the control as touched.
  void touch() {
    _updateTouched(true);
  }

  /// Marks the control as untouched.
  void untouch() {
    _updateTouched(false);
  }

  void _updateTouched(bool value) {
    if (_touched != value) {
      _touched = value;
      _touchChanges.add(_touched);
    }
  }

  /// Constructor of the [AbstractControl].
  AbstractControl({
    List<ValidatorFunction> validators,
    List<AsyncValidatorFunction> asyncValidators,
    int asyncValidatorsDebounceTime = 250,
    bool touched = false,
    bool disabled = false,
  })  : assert(asyncValidatorsDebounceTime >= 0),
        _validators = validators ?? const [],
        _asyncValidators = asyncValidators ?? const [],
        _asyncValidatorsDebounceTime = asyncValidatorsDebounceTime {
    updateStatus(disabled ? ControlStatus.disabled : ControlStatus.valid);
    _updateTouched(touched);
  }

  /// The list of functions that determines the validity of this control.
  ///
  /// In [FormGroup] these come in handy when you want to perform validation
  /// that considers the value of more than one child control.
  List<ValidatorFunction> get validators => List.unmodifiable(_validators);

  /// The list of async functions that determines the validity of this control.
  ///
  /// In [FormGroup] these come in handy when you want to perform validation
  /// that considers the value of more than one child control.
  List<AsyncValidatorFunction> get asyncValidators =>
      List.unmodifiable(_asyncValidators);

  /// The current value of the control.
  T get value => _value;

  /// Sets the value to the control
  set value(T value) {
    if (_value != value) {
      _value = value;
      this.validate();
      this.updateValue(_value);
    }
  }

  /// Gets the parent control.
  FormControlCollection get parent => this._parent;

  @protected
  set parent(FormControlCollection parent) {
    this._parent = parent;
  }

  /// An object containing any errors generated by failing validation,
  /// or empty [Map] if there are no errors.
  Map<String, dynamic> get errors => Map.unmodifiable(_errors);

  /// A [Stream] that emits the status every time it changes.
  Stream<ControlStatus> get statusChanged => _statusChanges.stream;

  /// A [Stream] that emits the value of the control every time it changes.
  Stream<T> get valueChanges => _valueChanges.stream;

  /// A [Stream] that emits an event every time the control
  /// is touched or untouched.
  Stream<bool> get touchChanges => _touchChanges.stream;

  /// A control is valid when its [status] is ControlStatus.valid.
  bool get valid => this.status == ControlStatus.valid;

  /// A control is invalid when its [status] is ControlStatus.invalid.
  bool get invalid => this.status == ControlStatus.invalid;

  /// A control is pending when its [status] is ControlStatus.pending.
  bool get pending => this.status == ControlStatus.pending;

  /// A control is disabled when its [status] is ControlStatus.disabled.
  bool get disabled => this.status == ControlStatus.disabled;

  /// A control is enabled as long as its [status] is
  /// not ControlStatus.disabled.
  bool get enabled => !this.disabled;

  /// True whether the control has validation errors.
  bool get hasErrors => _errors.keys.length > 0;

  /// The validation status of the control.
  ///
  /// There are four possible validation status values:
  /// * VALID: This control has passed all validation checks.
  /// * INVALID: This control has failed at least one validation check.
  /// * PENDING: This control is in the midst of conducting a validation check.
  ///
  /// These status values are mutually exclusive, so a control cannot be both
  /// valid AND invalid or invalid AND pending.
  ControlStatus get status => _status;

  /// Enables the control. This means the control is included in validation
  /// checks and the aggregate value of its parent. Its status recalculates
  /// based on its value and its validators.
  ///
  /// When [onlySelf] is true, mark only this control.
  /// When false or not supplied, marks all direct ancestors.
  /// Default is false.
  void enable({bool onlySelf: false}) {
    if (this.enabled) {
      return;
    }
    this.updateStatus(ControlStatus.pending, onlySelf: onlySelf);
    this.validate();
  }

  /// Disables the control.
  ///
  /// This means the control is exempt from validation checks and excluded
  /// from the aggregate value of any parent. Its status is `DISABLED`.
  ///
  /// If the control has children, all children are also disabled.
  ///
  /// When [onlySelf] is true, mark only this control.
  /// When false or not supplied, marks all direct ancestors.
  /// Default is false.
  void disable({bool onlySelf: false}) {
    _errors.clear();
    this.updateStatus(ControlStatus.disabled, onlySelf: onlySelf);
  }

  /// Disposes the control
  void dispose() {
    _statusChanges.close();
    _valueChanges.close();
    _asyncValidationSubscription?.cancel();
  }

  /// Resets the control.
  void reset();

  @protected
  void updateValue(T value, {bool onlySelf: false}) {
    _valueChanges.add(value);

    if (this.parent != null && !onlySelf) {
      this.parent.updateValueAndValidity();
    }
  }

  @visibleForTesting
  @protected
  void updateStatus(ControlStatus status, {bool onlySelf: false}) {
    if (this.status != status) {
      _status = status;
      _statusChanges.add(_status);

      if (_parent != null && !onlySelf) {
        _parent.updateStatusAndValidity();
      }
    }
  }

  /// Add errors when running validations manually, rather than automatically.
  ///
  /// ### Example:
  ///
  /// ```dart
  /// final passwordConfirmation = FormControl();
  ///
  /// passwordConfirmation.addError({'mustMatch': true});
  ///```
  ///
  /// See also [AbstractControl.removeError]
  void addError(Map<String, dynamic> error) {
    _errors.addAll(error);
    checkValidityAndUpdateStatus();
  }

  /// Remove errors by name.
  ///
  /// ### Example:
  ///
  ///```dart
  /// final passwordConfirmation = FormControl();
  ///
  /// passwordConfirmation.removeError('mustMatch');
  ///```
  ///
  /// See also [AbstractControl.addError]
  void removeError(String errorName) {
    _errors.remove(errorName);
    checkValidityAndUpdateStatus();
  }

  /// Sets errors on a form control when running validations manually,
  /// rather than automatically.
  void setErrors(Map<String, dynamic> errors) {
    _errors.clear();
    _errors.addAll(errors);
    checkValidityAndUpdateStatus();
  }

  /// This method is for internal use
  @protected
  void checkValidityAndUpdateStatus({bool onlySelf: false}) {
    this.updateStatus(
      this.hasErrors ? ControlStatus.invalid : ControlStatus.valid,
      onlySelf: onlySelf,
    );
  }

  /// Validates the current control.
  @protected
  void validate() {
    if (this.disabled) {
      return;
    }

    this.updateStatus(ControlStatus.pending);

    _errors.clear();
    this.validators.forEach((validator) {
      final error = validator(this);
      if (error != null) {
        _errors.addAll(error);
      }
    });

    if (_errors.keys.isNotEmpty || this.asyncValidators.isEmpty) {
      checkValidityAndUpdateStatus();
    } else {
      if (_debounceTimer != null) {
        _debounceTimer.cancel();
      }

      _debounceTimer =
          Timer(Duration(milliseconds: _asyncValidatorsDebounceTime), () {
        _runAsyncValidator();
      });
    }
  }

  StreamSubscription _asyncValidationSubscription;

  Future<void> _cancelExistingSubscription() async {
    if (_asyncValidationSubscription != null) {
      await _asyncValidationSubscription.cancel();
      _asyncValidationSubscription = null;
    }
  }

  /// runs async validators to validate the value of current control
  Future<void> _runAsyncValidator() async {
    await _cancelExistingSubscription();

    final validatorsStream = Stream.fromFutures(
        this.asyncValidators.map((validator) => validator(this)));

    final errors = Map<String, dynamic>();
    _asyncValidationSubscription = validatorsStream.listen(
      (error) {
        if (error != null) {
          errors.addAll(error);
        }
      },
      onDone: () {
        _errors.addAll(errors);
        if (this.pending) {
          checkValidityAndUpdateStatus();
        }
      },
    );
  }
}
