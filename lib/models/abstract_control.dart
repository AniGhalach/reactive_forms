import 'package:flutter/foundation.dart';

abstract class AbstractControl<T> {
  T get value;
  set value(T newValue);
  final _onStatusChanged = ValueNotifier<bool>(true);

  /// An object containing any errors generated by failing validation,
  /// or empty [Map] if there are no errors.
  final Map<String, dynamic> _errors = {};

  Map<String, dynamic> get errors => Map.unmodifiable(_errors);

  /// A [Stream] that emits an event every time the validation status of
  /// the control changes.
  ValueListenable<bool> get onStatusChanged => _onStatusChanged;

  ValueListenable<T> get onValueChanged;

  /// True if the control doesn't has validations errors.
  bool get valid => this.errors.keys.length == 0;

  /// True if the control has validations errors.
  bool get invalid => !this.valid;

  @protected
  void dispose() {
    _onStatusChanged.dispose();
  }

  /// Resets the control.
  void reset();

  /// Add errors when running validations manually, rather than automatically.
  ///
  /// ### Example:
  ///
  /// ```dart
  /// final passwordConfirmation = FormControl();
  ///
  /// passwordConfirmation.addError({'mustMatch': true});
  ///```
  ///
  /// See also [AbstractControl.removeError]
  ///
  void addError(Map<String, dynamic> error) {
    this._errors.addAll(error);
    notifyStatusChanged();
  }

  /// Remove errors by name.
  ///
  /// ### Example:
  ///
  ///```dart
  /// final passwordConfirmation = FormControl();
  ///
  /// passwordConfirmation.removeError('mustMatch');
  ///```
  ///
  /// See also [AbstractControl.addError]
  ///
  void removeError(String errorName) {
    this._errors.remove(errorName);
    notifyStatusChanged();
  }

  /// Sets errors on a form control when running validations manually,
  /// rather than automatically.
  ///
  void setErrors(Map<String, dynamic> errors) {
    this._errors.clear();
    this._errors.addAll(errors);
    notifyStatusChanged();
  }

  @protected
  void notifyStatusChanged() {
    this._onStatusChanged.value = this.valid;
  }
}
